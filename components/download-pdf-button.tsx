"use client";

import { useState } from "react";
import { Download, Loader2 } from "lucide-react";
import jsPDF from "jspdf";
import { Button } from "@/components/ui/button";
import { toast } from "sonner";
import { z } from "zod";
import type { SummaryPayload } from "@/lib/schemas";
import { summarySchema } from "@/lib/schemas";

// Type guard for structured summaries
function isStructuredSummary(summary: SummaryPayload): summary is z.infer<typeof summarySchema> {
  return summary && typeof summary === 'object' && 'quick_summary' in summary && typeof (summary as Record<string, unknown>).quick_summary === 'string';
}

type DownloadPdfButtonProps = {
  bookTitle: string;
  bookAuthor?: string | null;
  summary: SummaryPayload;
};

export function DownloadPdfButton({
  bookTitle,
  bookAuthor,
  summary,
}: DownloadPdfButtonProps) {
  const [isGenerating, setIsGenerating] = useState(false);

  const generatePDF = () => {
    setIsGenerating(true);
    
    try {
      // Ensure summary is structured
      if (!isStructuredSummary(summary)) {
        toast.error("Cannot generate PDF for raw text summaries");
        setIsGenerating(false);
        return;
      }
      
      const structuredSummary = summary;
      
      const doc = new jsPDF();
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 20;
      const maxWidth = pageWidth - 2 * margin;
      let yPosition = margin;

      // Helper function to add a new page if needed
      const checkNewPage = (requiredSpace: number = 20) => {
        if (yPosition + requiredSpace > pageHeight - margin) {
          doc.addPage();
          yPosition = margin;
        }
      };

      // Helper function to add text with word wrapping
      const addText = (text: string, fontSize: number = 12, isBold: boolean = false, align: 'left' | 'center' | 'right' = 'left') => {
        doc.setFontSize(fontSize);
        doc.setFont(undefined, isBold ? 'bold' : 'normal');
        
        const lines = doc.splitTextToSize(text, maxWidth);
        
        checkNewPage(lines.length * fontSize * 0.35);
        
        lines.forEach((line: string) => {
          if (yPosition + fontSize * 0.35 > pageHeight - margin) {
            doc.addPage();
            yPosition = margin;
          }
          
          const xPosition = align === 'center' 
            ? pageWidth / 2 
            : align === 'right' 
            ? pageWidth - margin 
            : margin;
          
          doc.text(line, xPosition, yPosition, {
            align: align === 'center' ? 'center' : align === 'right' ? 'right' : 'left',
            maxWidth: maxWidth,
          });
          
          yPosition += fontSize * 0.35;
        });
        
        yPosition += 5; // Add spacing after text
      };

      // Cover Page
      let coverYPosition = pageHeight / 2 - 40; // Start higher to accommodate multi-line titles
      
      // Title (with wrapping for long titles)
      doc.setFontSize(24);
      doc.setFont(undefined, 'bold');
      const titleLines = doc.splitTextToSize(bookTitle, maxWidth);
      titleLines.forEach((line: string) => {
        doc.text(line, pageWidth / 2, coverYPosition, { align: 'center' });
        coverYPosition += 30; // Spacing between title lines
      });
      
      // Author
      if (bookAuthor) {
        coverYPosition += 10; // Add spacing after title
        doc.setFontSize(16);
        doc.setFont(undefined, 'normal');
        const authorText = `By ${bookAuthor}`;
        const authorLines = doc.splitTextToSize(authorText, maxWidth);
        authorLines.forEach((line: string) => {
          doc.text(line, pageWidth / 2, coverYPosition, { align: 'center' });
          coverYPosition += 20;
        });
      }
      
      // Book Summary label
      coverYPosition += 10;
      doc.setFontSize(12);
      doc.text("Book Summary", pageWidth / 2, coverYPosition, { align: 'center' });
      
      // Generated by label
      coverYPosition += 15;
      doc.text(`Generated by BookByte`, pageWidth / 2, coverYPosition, { align: 'center' });
      
      // Add new page for content
      doc.addPage();
      yPosition = margin;

      // Quick Summary
      if (structuredSummary.quick_summary) {
        addText("QUICK SUMMARY", 18, true, 'center');
        checkNewPage(10);
        yPosition += 5;
        addText(structuredSummary.quick_summary, 12, false, 'left');
        checkNewPage(20);
        yPosition += 10;
      }

      // Key Ideas
      if (structuredSummary.key_ideas && structuredSummary.key_ideas.length > 0) {
        addText("KEY IDEAS", 18, true, 'center');
        checkNewPage(10);
        yPosition += 5;
        
        structuredSummary.key_ideas.forEach((idea, index) => {
          checkNewPage(30);
          addText(`${index + 1}. ${idea.title}`, 14, true);
          checkNewPage(10);
          yPosition += 2;
          addText(idea.text, 11, false);
          checkNewPage(15);
          yPosition += 10;
        });
      }

      // Chapters
      if (structuredSummary.chapters && structuredSummary.chapters.length > 0) {
        addText("CHAPTER SUMMARIES", 18, true, 'center');
        checkNewPage(10);
        yPosition += 5;
        
        structuredSummary.chapters.forEach((chapter, index) => {
          checkNewPage(30);
          addText(`Chapter ${index + 1}: ${chapter.title}`, 14, true);
          checkNewPage(10);
          yPosition += 2;
          
          const chapterContent = chapter.summary || (chapter as any).content || (chapter as any).text || '';
          addText(chapterContent, 11, false);
          checkNewPage(15);
          yPosition += 10;
        });
      }

      // Actionable Insights
      if (structuredSummary.actionable_insights && structuredSummary.actionable_insights.length > 0) {
        addText("ACTIONABLE INSIGHTS", 18, true, 'center');
        checkNewPage(10);
        yPosition += 5;
        
        structuredSummary.actionable_insights.forEach((insight, index) => {
          checkNewPage(20);
          addText(`${index + 1}. ${insight}`, 11, false);
          checkNewPage(10);
          yPosition += 8;
        });
      }

      // Quotes
      if (structuredSummary.quotes && structuredSummary.quotes.length > 0) {
        addText("QUOTES", 18, true, 'center');
        checkNewPage(10);
        yPosition += 5;
        
        structuredSummary.quotes.forEach((quote, index) => {
          checkNewPage(20);
          addText(`"${quote}"`, 11, false, 'center');
          checkNewPage(10);
          yPosition += 8;
        });
      }

      // Generate filename
      const sanitizedTitle = bookTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase();
      const filename = `${sanitizedTitle}_summary.pdf`;

      // Save the PDF
      doc.save(filename);
      
      toast.success("PDF downloaded successfully!");
    } catch (error) {
      console.error("Error generating PDF:", error);
      toast.error("Failed to generate PDF. Please try again.");
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <Button
      onClick={generatePDF}
      disabled={isGenerating}
      variant="outline"
      className="flex items-center gap-2"
    >
      {isGenerating ? (
        <>
          <Loader2 className="h-4 w-4 animate-spin" />
          Generating PDF...
        </>
      ) : (
        <>
          <Download className="h-4 w-4" />
          Download PDF
        </>
      )}
    </Button>
  );
}

